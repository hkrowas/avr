
start:
test_adiw:
  ldi   r26, 0x54
  ldi   r27, 0x21
  adiw  X, 0x8      ; test add constant to word
  cp    r26, 0x5c
  brne  1
  nop
  cp    r27, 0x21
  brne  1
  nop
test_sbiw:
  sbiw  X, 0x0c     ; test subtract from word
  cp    r26, 0x50
  brne  1
  nop
  cp    r27, 0x21
  brne  1
  nop
test_add:
  ldi   R1, 0
  ldi   R0, 58
  add   R1, R0      ; test add
  cp    R1, R0      ; r1 should be equal to r0
  brne  1
  nop
  brvs  1           ; previous add should not overflow
  nop
  ldi   r1, 0x7f    ; set up overflow add
  ldi   r0, 0x7f
  add   r1, r0
  brvc  1           ; branch if not set (i.e. overflow not detected)
  nop
test_sub:
  ldi   r0, 1
  ldi   r1, 1
  sub   R0, R1      ; check subtraction
  brne  1
  nop
test_adc:
  sec               ; set carry flag to test adc
  adc   r0, r0
  cpi   r0, 1
  brne  1
  nop
test_subi:
  subi  r0, 1       ; test subtraction by immediate
  brne  1
  nop
  sec
test_subc:
  subc  r0, r0      ; test subtraction with carry
  cpi   r0, -1
  brne  1
  nop
test_subci:
  sec               ; set carry to test subtraction by immediate with carry
  sbci  r0, 1
  cpi   r0, -3
  brne  1
  nop
test_and:
  ldi   r0, 0
  ldi   r1, 0xff
  and   r0, r1      ; test r1 & r0
  brne  1
  nop
  ldi   r0, 0xff
  and   r0, r1
  cpi   r0, 0xff
  brne  1
  nop
test_andi:
  andi  r0, 0x00    ; test and by immediate
  brne  1
  nop
test_or:
  ldi   r0, 0
  ldi   r1, 0
  or    r0, r1      ; test or
  brne  1
  nop
  ldi   r1, 0x46
  or    r0, r1      ; test or
  cpi   r0, 0x46
  brne  1
  nop
  ldi   r1, 0xff
  or    r0, r1
  cpi   r0, 0xff
  brne  1
  nop
test_ori:
  ldi   r0, 0
  ori   r0, 0x38    ; test or by immediate
  cpi   r0, 0x38
  brne  1
  nop
  eor   r0, r0      ; test exclusive or. r0 should be 0
  brne  1
  nop
test_com:
  com   r0          ; test one's complement
  cpi   r0, 0xff
  brne  1
  nop
  ldi   r0, 0x46
  com   r0
  cpi   r0, 0xB9
  brne  1
  nop
test_neg:
  neg   r0          ; test two's complement
  cpi   r0, 0x47
  brne  1
  nop
  ldi   r0, 0
test_sbr:
  sbr   r0, 0       ; test set first bit of r0
  cpi   r0, 0x01
  brne  1
  nop
  sbr   r0, 7       ; test set last bit of r0
  cpi   r0, 0x81
  brne  1
  nop
test_cbr:
  cbr   r0, 0       ; test clear last bit of r0
  cpi   r0, 0x80
  cbr   r0, 7       ; test clear first bit of r0
  brne  1
  nop
test_inc:
  ldi   r0, 0
  inc   r0          ; test increment
  cpi   r0, 1
  brne  1
  nop
test_dec:
  dec   r0          ; test decrement
  brne  1
  nop
test_tst:
  tst   r0, r0      ; test tst
  brne  1
  nop
  inc   r0
  ldi   r1, 0x02
  tst   r1, r0
  brne  1
  nop
test_clr:
  clr   r0          ; test set r0 to 0x00
  brne  1
  nop
test_ser:
  ser   r0          ; test set r0 to 0xff
  cpi   r0, 0xff
  brne
  nop
  ; Test data transfer instructions
  ldi   r0, 0x23
test_sts_lds:
  sts   0x0021, r0  ; W 0x23 0x0021 test store and load direct
  lds   r0, 0x0021  ; R 0x21 0x0021
  ldi   r26, 0x43
  ldi   r27, 0x02
  sts   X, r0       ; W 0x23 0x0243 test store and load indirect
  lds   r0, X       ; R 0x23 0x0243
  ldi   r28, 0x43
  ldi   r29, 0x02
  sts   Y, r0       ; W 0x23 0x0243
  lds   r0, Y       ; R 0x23 0x0243
  ldi   r30, 0x43
  ldi   r31, 0x02
  sts   Z, r0       ; W 0x23 0x0243
  lds   r0, Z       ; R 0x23 0x0243
  ldi   r0, 0x29
test_std_ldd:
  std   Y+5, r0     ; W 0x29 0x0248 test store and load indirect with displacement
  clr   r0
  ldd   r0, Y+5     ; R 0x29 0x0248
  st    Y+, r0      ; W 0x29 0x0243
  st    Y+, r0      ; W 0x29 0x0244
  ld    r0, -Y      ; R 0x29 0x0243
  ldi   r1, 0x54
  mov   r0, r1      ; test mov
  cpi   r0, 0x54
  brne  1
  nop
  ldi   r0, 0x32    ; test load immediate
  cpi   r0, 0x32
  ldi   r26, 0x5a   ; test move word (X = 0x865a)
  ldi   r27, 0x86
test_movw:
  movw  Y, X        ; Y = X = 0x8651
  cpi   r28, 0x5a
  brne  1
  nop
  cpi   r29, 0x86
  brne  1
  nop
  nop

test_rjump:
  RJUMP 1 		;testing relative jump
	NOP				;should not execute
	JMP testJump	;jump to address in memory
	NOP				;should skip over this

testJump:
	SEI				;set the interrupt flag
	BRIE testInt	;tests to see if the interrupt flag is set
	NOP				;should not execute

testInt:
	CLI				;clears the interrupt flag
	BRIE 2			;tests to see if the branch instruction is working
	BRID testIClr	;tests to see if the interrupt flag is cleared
	NOP				;should not execute

testIClr:
	SEC				;sets the carry flag
	BRCC 2			;should not skip next line if carry is set
	NOP				;
	BRCS testCSet	;tests to see if carry is set
	NOP				;should not execute

testCSet:
	CLC				;clears the carry flag
	BRCS 2			;tests the branch instruction is working
	BRCC testCClr	;tests to see if the carry flag is cleared
	NOP				;shoud not execute

testCClr:
	SEN				;sets the negative flag
	BRPL 2			;should not skip next line if negative is set
	NOP				;
	BRMI testNSet	;tests to see if negative is set
	NOP				;should not execute

testNSet:
	CLN				;clears the negative flag
	BRMI 2			;tests the branch instruction is working
	BRPL testNClr	;tests to see if the negative flag is cleared
	NOP				;shoud not execute

testNClr:
	SEV				;sets the overflow flag
	BRVC 2			;should not skip next line if overflow is set
	NOP				;
	BRVS testVSet	;tests to see if overflow is set
	NOP				;should not execute

testVSet:
	CLV				;clears the overflow flag
	BRVS 2			;tests the branch instruction is working
	BRVC testVClr	;tests to see if the overflow flag is cleared
	NOP				;shoud not execute

testVClr:
	BRLT 2			;Tests lower than but should not execute
	BRGE testGE		;N flag is cleared so this tests greater than or equal
	NOP				;Should not execute

testGE:
	SEV				;Set the overflow flag
	SEN				;Set the negative flag
	BRGE 2			;Tests greater than or equal but should not execute
	BRLT testLT		;N flag is set so this tests lower than
	NOP				;Sould not execute

testLT:
  	LDI R16, 2  	;setup the registers to test for CPC
  	LDI R17, 1
  	SEC				;set the carry flag
  	CPC R16, R17	;result should be 0 and set the zero flag
  	BRNE 2			;tests if result is not equal but should jump
  	BREQ testZset	;tests the brach if zero instruction
  	NOP				;should not execute

testZSet:
	CLZ				;clears the zero flag
	BREQ 2			;tests the brach if equal instruction
	BRNE testZClr	;tests the branch if not equal instruction
	NOP				;should not execute

testZClr:
	LDI R16, 130	;load 0b10000010 into R16 register to test LSL
	LSL R16			;this command should set the carry flag
	BRCS testLSLC	;should branch since carry should be set
	NOP				;should not be executed

testLSLC:
	CMPI R16, 4		;this should test if the shift left actually worked
	BREQ LSLWorks	;
	NOP				;should not be executed

LSLWorks:
	ROL R16			;this should see if the rotate right thorugh carry works
	CPI R16, 9		;this sould be the result if the rotate worked
	BREQ ROLWorks	;
	NOP				;Should not be executed

ROLWorks:
	LDI	R16, 130	;setup with signed bit set
	ASR	R16			;sign bit should be set
	CPI R16, 129	;check to see if only the right 7 bits shifted
	BREQ ASRWorks	;
	NOP				;should not be executed

ASRWorks:
	NOP				;end of test
